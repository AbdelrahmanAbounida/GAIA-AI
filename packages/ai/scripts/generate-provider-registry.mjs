#!/usr/bin/env node
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const OUTPUT_PATH = path.resolve(
  __dirname,
  "../src/vectorstores/_providers.generated.ts",
);

const ALL_PROVIDERS = [
  "faiss",
  "pinecone",
  "qdrant",
  "chroma",
  "weaviate",
  "milvus",
  "pgvector",
  "lancedb",
  "supabase",
];

const BASIC_PROVIDERS = ["lancedb", "pinecone"];

const PROVIDER_CLASS_NAMES = {
  faiss: "FaissVectorStore",
  pinecone: "PineconeVectorStore",
  qdrant: "QdrantVectorStore",
  chroma: "ChromaVectorStore",
  weaviate: "WeaviateVectorStore",
  milvus: "MilvusVectorStore",
  pgvector: "PGVectorVectorStore",
  lancedb: "LanceDBVectorStore",
  supabase: "SupabaseVectorStore",
};

const PROVIDER_IMPORT_PATHS = {
  faiss: "./faiss",
  pinecone: "./pinecone",
  qdrant: "./qdrant",
  chroma: "./chroma",
  weaviate: "./weaviate",
  milvus: "./milvus",
  pgvector: "./pgvector",
  lancedb: "./lancedb",
  supabase: "./supabase",
};

const ALL_FTS_PROVIDERS = ["flexsearch", "minisearch", "orama", "native"];
const BASIC_FTS_PROVIDERS = ["flexsearch"];

const FTS_CLASS_NAMES = {
  flexsearch: "FlexSearchFullTextSearch",
  minisearch: "MiniSearchFullTextSearch",
  orama: "OramaFullTextSearch",
};

const FTS_IMPORT_PATHS = {
  flexsearch: "./fulltext/flexsearch-provider",
  minisearch: "./fulltext/minisearch",
  orama: "./fulltext/orama",
};

function resolveProviders(envValue) {
  if (!envValue || envValue === "all") {
    return { providers: ALL_PROVIDERS, ftsProviders: ALL_FTS_PROVIDERS };
  }
  if (envValue === "basic") {
    return { providers: BASIC_PROVIDERS, ftsProviders: BASIC_FTS_PROVIDERS };
  }
  const providers = envValue
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);
  return { providers, ftsProviders: ALL_FTS_PROVIDERS };
}

function generate(providers, ftsProviders) {
  const lines = [
    "// AUTO-GENERATED by scripts/generate-provider-registry.mjs â€” DO NOT EDIT",
    'import type { VectorStoreProviderId, FullTextSearchProviderId } from "./types";',
    "",
    `export const INCLUDED_PROVIDERS: VectorStoreProviderId[] = [${providers.map((p) => `"${p}"`).join(", ")}];`,
    "",
    `export const INCLUDED_FTS_PROVIDERS: FullTextSearchProviderId[] = [${ftsProviders.map((p) => `"${p}"`).join(", ")}];`,
    "",
    "export async function loadProviderModule(provider: VectorStoreProviderId) {",
    "  switch (provider) {",
  ];

  for (const p of providers) {
    const cls = PROVIDER_CLASS_NAMES[p];
    const imp = PROVIDER_IMPORT_PATHS[p];
    lines.push(`    case "${p}": {`);
    lines.push(`      const { ${cls} } = await import("${imp}");`);
    lines.push(`      return ${cls};`);
    lines.push("    }");
  }

  lines.push("    default:");
  lines.push("      return undefined;");
  lines.push("  }");
  lines.push("}");
  lines.push("");

  lines.push(
    "export async function loadFTSProviderModule(provider: FullTextSearchProviderId) {",
  );
  lines.push("  switch (provider) {");

  for (const p of ftsProviders) {
    if (p === "native") continue;
    const cls = FTS_CLASS_NAMES[p];
    const imp = FTS_IMPORT_PATHS[p];
    lines.push(`    case "${p}": {`);
    lines.push(`      const { ${cls} } = await import("${imp}");`);
    lines.push(`      return ${cls};`);
    lines.push("    }");
  }

  lines.push("    default:");
  lines.push("      return undefined;");
  lines.push("  }");
  lines.push("}");
  lines.push("");

  return lines.join("\n");
}

const envValue = process.env.GAIA_VECTORSTORE_PROVIDERS;
const { providers, ftsProviders } = resolveProviders(envValue);

console.log(
  `Generating provider registry: providers=[${providers.join(", ")}] fts=[${ftsProviders.join(", ")}]`,
);

const content = generate(providers, ftsProviders);
fs.mkdirSync(path.dirname(OUTPUT_PATH), { recursive: true });
fs.writeFileSync(OUTPUT_PATH, content, "utf-8");

console.log(`Written to ${OUTPUT_PATH}`);
